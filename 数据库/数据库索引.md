# 数据库索引

## 原因:

数据在磁盘上是以块的形式存储的。为确保对磁盘操作的原子性，访问数据的时候会一并访问所有数据块

磁盘上的这些数据块与链表类似，即它们都包含一个数据段和一个指针，指针指向下一个节点（数据块）的内存地址，而且它们都不需要连续存储（即逻辑上相邻的数据块在物理上可以相隔很远）

| Identity | Name   | Age  | Grade |
| -------- | ------ | ---- | ----- |
| 1        | Robin  | 28   | 90    |
| 5        | Lilei  | 26   | 60    |
| 3        | Hanmei | 25   | 50    |
| 4        | Lucy   | 27   | 66    |
| 2        | Lily   | 29   | 80    |

要查找Lily *select \* from User where* *Iden**tity**= 2.*

实际需要从上到下 查5次

 为了加快搜索速度，这里就出现了索引

索引是对某个字段进行排序的一种方式

对表中的某个字段建立索引会创建另一种数据结构，其中保存着字段的值，每个值又指向与它相关的记录

这种索引的数据结构是经过排序的，因而可以对其执行二分查找。

*对上个表的**I**dentity**字段进行索引，就是在数据库存储空间上创建一块专用的控件，把**User**表的所有的**Identity**字段的值拿出来放到这里，并且对这些值进行排序，并且每个值都携带着这个**Identity**对应的行所在数据块的地址。*

*因为**Identity**是进过排序的，按照一定的数据结构存储的，所以数据库引擎在查找的时候，比如说查找**identity**为**5**，引擎就会计算，**5**大概在整个排序结构的大致地方，然后到那里去拿出这个值看看是不是，不是的话就再次相应的向左或者向右移动去寻找。*

---

#### 总结:就是根据你指定的列，建立一个遵循一定数据结构的区域，这些区域可以快速定位到相应数据库字段所在的磁盘地址。

## 好处

```
优点：
    1.大大加快数据的检索速度;   
    2.创建唯一性索引，保证数据库表中每一行数据的唯一性;   
    3.加速表和表之间的连接;   
    4.在使用分组和排序子句进行数据检索时，可以显著减少查询中分组和排序的时间。
```

```
缺点：
　　1.索引需要占用数据表以外的物理存储空间
　　2.创建索引和维护索引要花费一定的时间
　　3.当对表进行更新操作时，索引需要被重建，这样降低了数据的插入和修改速度。
```

> **是否走索引取决于这条查询语句的where子句**

*数据库引擎发现你的**where**语句中有**identity**，那么就会从**identity**的索引数据结构中进行检索*

**select ** 会降低检索速度，这个跟索引没关系，**se**lect 降低检索速度，是因为从数据库服务器端到客户端的网络传输是有时间的，**select ** 中难免包含着不必要的字段，所以传输起来会比较慢

## 索引定义

[索引](http://baike.baidu.com/view/262241.htm)是对数据库表中一个或多个列（例如，employee 表的姓氏 (lname) 列）的值进行排序的结构

**数据库索引并不存储这个表中其他列（字段）的值**

## 索引类型

根据数据库的功能，可以在数据库设计器中创建索引

> 唯一索引：   UNIQUE     例如：create unique index stusno on student（sno）；

表明此索引的每一个索引值只对应唯一的数据记录，对于单列惟一性索引，这保证单列不包含重复的值。对于多列惟一性索引，保证多个值的组合不重复。

> 主键索引：   primary key

数据库表经常有一列或列组合，其值唯一标识表中的每一行。该列称为表的  **主键**。 

在数据库关系图中为表定义主键将自动创建主键索引，主键索引是唯一索引的特定类型

该索引要求主键中的每个值都唯一

当在查询中使用主键索引时，它还允许对数据的快速访问

> 聚集索引（也叫聚簇索引）：cluster 

在聚集索引中，表中行的物理顺序与键值的逻辑（索引）顺序相同。一个表只能包含一个聚集索引。   如果某索引不是聚集索引，则表中行的物理顺序与键值的逻辑顺序不匹配。与非聚集索引相比，聚集索引通常提供更快的数据访问速度。

> InnoDB 主键使用的是聚簇索引

常规索引（INDEX）

全文索引（FULLTEXT）

## 具体实例

### 使用SQL创建索引：

```mysql
CREATE INDEX name_index ON Employee (Employee_Name)
```

创建联合索引  在雇员表上创建两个列的联合索引，SQL如下：

```mysql
CREATE INDEX name_index ON Employee (Employee_Name, Employee_Age)
```

**基本原则是只如果表中某列在查询过程中使用的非常频繁，那就在该列上创建索引**

## **索引的优化**

① 最左前缀匹配原则 
② 对 where,on,group by,order by 中出现的列使用索引 
③ 尽量选择区分度高的列作为索引 
④ 对较小的数据列使用索引,这样会使索引文件更小 
⑤ 对于like查询，”%”不要放在前面。

```sql
SELECT * FROM houdunwang WHERE uname LIKE'后盾%' -- 走索引 
SELECT * FROM houdunwang WHERE uname LIKE "%后盾%" -- 不走索引
```

## **什么时候不使用索引**

> 查询中很少使用到的列 不应该创建索引
>
> 如果建立了索引然而还会降低mysql的性能和增大了空间需求.

> 很少数据的列也不应该建立索引
>
> 比如 一个性别字段 0或者1,在查询中,结果集的数据占了表中数据行的比例比较大,mysql需要扫描的行数很多,增加索引,并不能提高效率 

> 定义为text和image和bit数据类型的列不应该增加索引, 

> 当表的修改(UPDATE,INSERT,DELETE)操作远远大于检索(SELECT)操作时不应该创建索引,这两个操作是互斥的关系

## 索引的实现方式

### B+ 树

索引的实现通常使用B树及其变种B+树 

> 因为它们是时间复杂度低， 查找、删除、插入操作都可以可以在对数时间内完成。

> 另外一个重要原因存储在B-Tree中的数据是有序的。 

![img](https://img2018.cnblogs.com/blog/1500160/201903/1500160-20190313175408071-1279530828.png)

节点下面可以有多个子节点，数据库开发商会设置子节点数的一个最大值，这个值不会太小，所以B+树一般来说比较矮胖

- 非叶子节点的字数指针与关键字的个数相同
- 非叶子节点的字数指针P[i]，指向关键字值[K[i],K[i+1]]的子树
- 非叶子节点仅用来索引，数据保存在叶子节点中
- 所有叶子节点均有一个链指针指向下一个叶子节点（方便做索引）

B+Tree更加适合用来做存储索引

- B+树的磁盘读写代价更低
- B+树的查询效率更加稳定
- B+树更有利于对数据库的扫描

### 散列索引 哈希表 Hash索引

通过散列函数来定位的一种索引 

![img](https://img2018.cnblogs.com/blog/1500160/201903/1500160-20190313175431282-2024448108.png)

在寻找值时哈希表效率极高    对于比较字符串是否相等的查询能够极快的检索出的值

> **为什么不用HashMap** 
>
> 哈希表是无顺的数据结构，对于很多类型的查询语句哈希索引都无能为力

#### 缺点

- 仅仅满足“=”，“IN”，不能用于范围查询
- 无法被用来避免数据的排序操作（hashcode是经过hash函数后得出的）
- 不能利用部分索引键查询
- 不能避免表扫描
- 遇到大量Hash相等的情况下不能比B-Tree的索引高

### 位图索引 BitMap

  位图索引是一种针对多个字段的简单查询设计一种特殊的索引，适用范围比较小，只适用于字段值固定并且值的种类很少的情况

#### 密集索引和稀疏索引的区别

- 密集索引文件中的每个搜索码都对应一个索引值
- 稀疏索引文件只为索引码的某些值创建索引项

![img](https://img2018.cnblogs.com/blog/1500160/201903/1500160-20190313175449429-288439317.png)

InnoDB

- 若一个主键被定义，则该主键被作为密集索引
- 若没有主键被定义，该表的第一个唯一非空索引则作为密集索引
- 若不满足以上条件，innodb内部会自动生成一个隐藏主键（密集索引）
- 非主键索引存储相关键位和其对应的主键值，包含两次查找

![img](https://img2018.cnblogs.com/blog/1500160/201903/1500160-20190313175511730-1331704992.png)





---

### 慢查询

分析MySQL语句查询性能的方法除了使用 EXPLAIN 输出执行计划，还可以让MySQL记录下查询超过指定时间的语句，我们将超过指定时间的[SQL语句](https://baike.baidu.com/item/SQL语句/5714895)查询称为“慢查询”。

### 开启慢查询

slow_query_log 慢查询开启状态
slow_query_log_file 慢查询日志存放的位置（这个目录需要MySQL的运行帐号的可写权限，一般设置为MySQL的数据存放目录）
long_query_time 查询超过多少秒才记录



> 1.查看慢查询相关参数

```mysql
mysql> show variables like 'slow_query%';
+---------------------------+----------------------------------+
| Variable_name             | Value                            |
+---------------------------+----------------------------------+
| slow_query_log            | OFF                              |
| slow_query_log_file       | /mysql/data/localhost-slow.log   |
+---------------------------+----------------------------------+

mysql> show variables like 'long_query_time';
+-----------------+-----------+
| Variable_name   | Value     |
+-----------------+-----------+
| long_query_time | 10.000000 |
+-----------------+-----------+
```

> 2.设置方法

方法一：全局变量设置

将 slow_query_log 全局变量设置为“ON”状态

```mysql
mysql> set global slow_query_log='ON'; 
```

设置慢查询日志存放的位置

```mysql
mysql> set global slow_query_log_file='/usr/local/mysql/data/slow.log';
```

查询超过1秒就记录

```mysql
mysql> set global long_query_time=1;
```

方法二：配置文件设置
修改配置文件my.cnf，在[mysqld]下的下方加入

```mysql
[mysqld]
slow_query_log = ON
slow_query_log_file = /usr/local/mysql/data/slow.log
long_query_time = 1
```

3.重启MySQL服务

```mysql
service mysqld restart
```

4.查看设置后的参数

```mysql
mysql> show variables like 'slow_query%';
+---------------------+--------------------------------+
| Variable_name       | Value                          |
+---------------------+--------------------------------+
| slow_query_log      | ON                             |
| slow_query_log_file | /usr/local/mysql/data/slow.log |
+---------------------+--------------------------------+

mysql> show variables like 'long_query_time';
+-----------------+----------+
| Variable_name   | Value    |
+-----------------+----------+
| long_query_time | 1.000000 |
+-----------------+----------+
```

### 四、测试

1.执行一条慢查询SQL语句

```mysql
mysql> select sleep(2);
```

2.查看是否生成慢查询日志

```mysql
ls /usr/local/mysql/data/slow.log
```

如果日志存在，MySQL开启慢查询设置成功！